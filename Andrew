#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define MAX_ROWS 9
#define MAX_COLS 9
#define MAX_PLAYERS 6
#define MAX_NAME_LENGTH 49
#define PLAYER_NAME_BUFFER 50 

typedef struct {
    char player_name[PLAYER_NAME_BUFFER];
    int score;
    int penguins;
    int id_player; 
} Player;

typedef struct {
    int fishes; // Number of fish in cell
    int penguin; // Penguin ID
    int broken; // Check if case is occupied (1 for yes, 0 for no)
    int playeron;
} Cell;

void clear_input_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        
    }
}


void setupPlayers(Player* players, int num_players, char** colors) {
    char buffer[PLAYER_NAME_BUFFER + 1]; // +1 for newline
    for (int i = 0; i < num_players; i++) {
        while (1) {
            printf("Enter name for player %d (up to 49 characters): ", i + 1);
            if (fgets(buffer, sizeof(buffer), stdin)) {
                // Check if input was too long
                if (buffer[strlen(buffer) - 1] != '\n') {
                    printf("Name entered is too long. Please enter a name up to 49 characters.\n");
                    clear_input_buffer(); // Clear remaining characters in the input buffer
                    continue; // Prompt for input again
                }

                // Remove newline character if present
                buffer[strcspn(buffer, "\n")] = 0;

                if (strlen(buffer) > MAX_NAME_LENGTH) {
                    printf("Name entered is too long. Please enter a name up to 49 characters.\n");
                    continue; // Prompt for input again
                }

                strcpy(players[i].player_name, buffer);
                break; // Exit the while loop
            } else {
                clear_input_buffer(); // Just in case fgets failed due to an error
                printf("Input error. Please try again.\n");
            }
        }

        players[i].score = 0;
        if (num_players == 2) {
            players[i].penguins = 4;
        } else if (num_players == 3) {
            players[i].penguins = 3;
        } else {
            players[i].penguins = 2;
        }

        // Display the player with their color
        printf("Player %d: %s %s\n", i + 1, colors[i], players[i].player_name);
    }
}


void printHexagonLine(int cols) {
   
    printf("\n");
    cols = (cols+1)/2;

     for (int i = 0; i < cols - 1; i++) {
        printf(" /      \\");
        printf("       ");
    }
    printf(" /      \\");
    printf("\n");
    
	for (int i = 0; i < cols - 1; i++) {
	    printf("/        \\");
	    printf("______");  
	}
	printf("/        \\");
    
    printf("\n");
    	for (int i = 0; i < cols - 1; i++) {
        printf("\\        /");
        printf("      ");
    }printf("\\        /");
    printf("\n");
	for (int i = 0; i < cols - 1; i++) {
        printf(" \\______/ ");
        printf("      ");
    }printf(" \\______/ ");
}
void printboard(Cell** board,int rows, int cols){
     for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
         	int k=(j+(i*9))+1;
         	printf("\x1B[%d;80H",k);	
            printf("Cell[%d][%d]: üêü=%d, üêß=%d, broken=%d, Player on is %d\n", i, j, board[i][j].fishes, board[i][j].penguin, board[i][j].broken, board[i][j].playeron);
        }
    }
}


Cell** initializeBoard(int rows, int cols) {
    srand(time(NULL)); 
    
    
    Cell** board = (Cell**)malloc(rows * sizeof(Cell*));
    for (int i = 0; i < rows; i++) {
        board[i] = (Cell*)malloc(cols * sizeof(Cell));
    }

    // initialize cell with fish from 1 to 3
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            int luck= rand() % 2 + 1;	
            if(i==0 && j%2 !=0){
            board[i][j].fishes = 0;
            board[i][j].penguin = 0;
            board[i][j].broken = 0;
            board[i][j].playeron = 0;
            }
            else if(luck==1) {
            board[i][j].fishes = rand() % 3 + 1; // between 1 and 3 fish
            board[i][j].penguin = 0;
            board[i][j].broken = 0;
            board[i][j].playeron = 0;
            }
            else{
            board[i][j].fishes = rand() % 2 + 2; // between 2 or 3 fish
            board[i][j].penguin = 0;
            board[i][j].broken = 0;
            board[i][j].playeron = 0;
            }
        }
    }
  

    printboard(board,rows,cols);

    return board;
}

// Function to release allocated memory
void freeBoard(Cell** board, int rows) {
    for (int i = 0; i < rows; i++) {
        free(board[i]);
    }
    free(board);
}

void printfishes(Cell** board,int rows, int cols){
  printf("\x1B[3;1H");
  for(int i = 0; i < rows; i++){
    for(int j = 0; j < cols; j++){
      if(i==0){
        if(j%2==0){
        	if(j==cols-1){
			if (board[i][j].fishes == 0){
			    printf("/        \\");
			   
			  }
			  else if(board[i][j].fishes == 1){
			    printf("/   üêü   \\");
			    
			  }
			  else if(board[i][j].fishes == 2){
			    printf("/  üêüüêü  \\");
			    
			  }
			  else if(board[i][j].fishes == 3){
			    printf("/ üêüüêüüêü \\");
			    
			  }
        	}
        	else{
        		 if (board[i][j].fishes == 0){
			    printf("/        \\");
			    printf("______");
			  }
			  else if(board[i][j].fishes == 1){
			    printf("/   üêü   \\");
			    printf("______");
			  }
			  else if(board[i][j].fishes == 2){
			    printf("/  üêüüêü  \\");
			    printf("______");
			  }
			  else if(board[i][j].fishes == 3){
			    printf("/ üêüüêüüêü \\");
			    printf("______");
          		  }
        	}	
        
        }
      }
      else{
        if(j%2==0){
        int y=4*i+3;
        int x=(j*8)+1;
        printf("\x1B[%d;%dH",y,x);
          if (board[i][j].fishes == 0){
            printf("/        \\");
          
          }
          else if(board[i][j].fishes == 1){
            printf("/   üêü   \\");
            
          }
          else if(board[i][j].fishes == 2){
            printf("/  üêüüêü  \\");
            
          }
          else if(board[i][j].fishes == 3){
            printf("/ üêüüêüüêü \\");
            
          }
          
        }
	      else if(j%2==1){
		int y=(4*i)+1;
		int x=9+(8*(j-1));
		printf("\x1B[%d;%dH",y,x);
		if (board[i][j].fishes == 0){
		  printf("/        \\");

		}
		else if(board[i][j].fishes == 1){
		  printf("/   üêü   \\");

		}
		else if(board[i][j].fishes == 2){
		  printf("/  üêüüêü  \\");

		}
		else if(board[i][j].fishes == 3){
		  printf("/ üêüüêüüêü \\");

        	}		
             }		
      }
    }
  }

}




void affichePenguin(Cell** board, int rows, int cols, int num_players, char** colors) {
    

    srand(time(NULL)); // Initialize random number generator for different outcomes each run

    int penguins_per_player;
    if (num_players >= 5) {
        penguins_per_player = 1;
    } else if (num_players == 4) {
        penguins_per_player = 2;
    } else if (num_players == 3) {
        penguins_per_player = 3;
    } else if (num_players == 2) {
        penguins_per_player = 4;
    } else {
        penguins_per_player = 0; // Assuming no players or invalid input
    }

    int total_penguins = num_players * penguins_per_player;
    for (int i = 0; i < total_penguins; i++) {
        int newrows, newcols;
        do {
            newrows = rand() % rows;
            newcols = rand() % cols;
        } while (board[newrows][newcols].penguin != 0 || (newrows == 0 && newcols % 2 != 0) || board[newrows][newcols].broken == 1);

        int posx, posy;
        if (newcols % 2 == 0) {
            posx = 5 + (newcols * 8);
            posy = 4 + (newrows * 4);
        } else {
            posx = 13 + ((newcols - 1) * 8);
            posy = 6 + ((newrows - 1) * 4);
        }

        int player_index = i / penguins_per_player; // Determine which player this penguin belongs to
        printf("\x1B[%d;%dH%s", posy, posx, colors[player_index]); // Display penguin with player-specific color
        board[newrows][newcols].penguin = player_index + 1;
        board[newrows][newcols].fishes = 1;
    }
    printboard(board, rows, cols);
}




//upper cell///////////////////////////////////////////////////////////////////
int verifyT(Cell **board, int crows, int ccols, int rows, int cols){
  //upper cell
  if ((board[crows][ccols + 1].penguin ==0 && board[crows][ccols + 1].broken == 0)) {
      return 1;
  } 
  else {
      return 0;
  }

}

//lower cell///////////////////////////////////////////////////////////////////
int verifyL(Cell **board, int crows, int ccols, int rows, int cols){
  //lower cell
  if ((board[crows + 1][ccols].penguin ==0 && board[crows + 1][ccols].broken == 0)) {
      return 1;
  } 
  else {
      return 0;
  }
}
//right upper cell///////////////////////////////////////////////////////////////////

int verifyTR(Cell **board, int crows, int ccols, int rows, int cols){
  //right upper cell even col
  if(ccols%2==0){
       if ((board[crows][ccols + 1].penguin ==0 && board[crows][ccols + 1].broken == 0)) {
         return 1;
       } 
       else {
         return 0;
       }
     }

  else{
    //right upper cell odd col

     if ((board[crows-1][ccols + 1].penguin ==0 && board[crows][ccols + 1].broken == 0)) {
       return 1;
     } 
     else {
       return 0;
     }
  }
}


//right lower cell///////////////////////////////////////////////////////////////////

int verifyLR(Cell **board, int crows, int ccols, int rows, int cols){
  //right lower case even cols
  if(ccols%2==0){

    if ((board[crows+1][ccols + 1].penguin ==0 && board[crows+1][ccols + 1].broken == 0)) {
        return 1;
    } else {
        return 0;
    }
  }
    //right lower cell even cols

  else{
    if ((board[crows][ccols + 1].penguin ==0 && board[crows][ccols + 1].broken == 0)) {
      return 1;
    } 
    else {
      return 0;
    }
  }
 
}

//left lower cell///////////////////////////////////////////////////////////////////

int verifyLL(Cell **board, int crows, int ccols, int rows, int cols){
    if(ccols%2==0){

      if ((board[crows+1][ccols - 1].penguin ==0 && board[crows+1][ccols - 1].broken == 0)) {
          return 1;
      } 
      else {
          return 0;
      }
    }
      //left lower cell odd col

    else{
      if ((board[crows][ccols - 1].penguin ==0 && board[crows][ccols - 1].broken == 0)) {
        return 1;
      } 
      else {
        return 0;
      }
    }

}


int verifyTL(Cell **board, int crows, int ccols, int rows, int cols){
  if(ccols%2==0){

    if ((board[crows][ccols - 1].penguin ==0 && board[crows][ccols - 1].broken == 0)) {
      return 1;
    } 
    else {
      return 0;
    }
  }
        //right lower cell odd col

  else{
        if ((board[crows- 1][ccols - 1].penguin ==0 && board[crows- 1][ccols - 1].broken == 0)) {
          return 1;
        } 
        else {
          return 0;
        }
      }
 }




int possiblemove(Cell **board, int crows, int ccols, int rows, int cols) {
//this function is used to count the number of directions possible for a player, 
//but i realized after 180 lines of code that it was smarter to create 6 other functions like "verif right left.."
  

  int posmove = 0;
  // first line /////////////////////////////////////////////////////////
  if (crows == 0) { 
    // first col of the first row 
    if (ccols == 0) {
      //right lower cell
      posmove += verifyLR(board, crows, ccols, rows, cols);
      // under
      posmove += verifyL(board, crows, ccols, rows, cols);

    }

    //cell between the first and last col
    else if (ccols % 2 == 0 && ccols != 0 && ccols!=cols-1) {
      //case en bas a droite
      posmove += verifyLR(board, crows, ccols, rows, cols);

      //case en dessous
      posmove += verifyL(board, crows, ccols, rows, cols);

      //case en bas a gauche
      posmove += verifyLL(board, crows, ccols, rows, cols);

    } 
    // first row last col

    else {
      //lower cell
      posmove += verifyL(board, crows, ccols, rows, cols);

      /left lower cell
      posmove += verifyLL(board, crows, ccols, rows, cols);

    }
  }

    

  ///last row//////////////////////////////////////////////////////////////////////////
  else if(crows==rows-1){
   //first col
    if(ccols==0){
     //top cell
      posmove += verifyT(board, crows, ccols, rows, cols);

      //right top cell
      posmove += verifyTR(board, crows, ccols, rows, cols);

    }
    //cell between first and last col on the last row of even cols
    else if (ccols % 2 == 0 && ccols != 0 && ccols!=cols-1){
      //top left cell 
      posmove += verifyTL(board, crows, ccols, rows, cols);

      //top cell
      posmove += verifyT(board, crows, ccols, rows, cols);

      //top right cell
      posmove += verifyTR(board, crows, ccols, rows, cols);


    }
      //cell between the first and last col on the last row of odd cols 
    else if (ccols % 2 != 0  && ccols!=cols-1){
      //top left cell
      posmove += verifyTL(board, crows, ccols, rows, cols);

      //top cell
      posmove += verifyT(board, crows, ccols, rows, cols);

      //top right cell
      posmove += verifyTR(board, crows, ccols, rows, cols);

      //left lower cell
      posmove += verifyLL(board, crows, ccols, rows, cols);

      //right lower cell
      posmove += verifyLR(board, crows, ccols, rows, cols);


      }

    //last col
    else{
      //top left cell
      posmove += verifyTL(board, crows, ccols, rows, cols);

      //top cell
      posmove += verifyT(board, crows, ccols, rows, cols);

      
    }

  }
  ///last first cell /////////////////////////////////////////////////////////////////
  else if(ccols==0 && crows!=0 && crows!= rows-1){
    //top cell
    posmove += verifyT(board, crows, ccols, rows, cols);

    //top right cell
    posmove += verifyTR(board, crows, ccols, rows, cols);

    //right lower cell
    posmove += verifyLR(board, crows, ccols, rows, cols);
    //lower cell
    posmove += verifyL(board, crows, ccols, rows, cols);

  }
  else if(ccols==cols-1 && crows!=0 && crows!= rows-1){
    //upper cell
    posmove += verifyT(board, crows, ccols, rows, cols);

    //left upper cell
    posmove += verifyTL(board, crows, ccols, rows, cols);

    //left lower cell
    posmove += verifyLL(board, crows, ccols, rows, cols);
    //case en bas 
    posmove += verifyL(board, crows, ccols, rows, cols);

  }
  else{
    //upper left cell
    posmove += verifyTL(board, crows, ccols, rows, cols);

    //upper cell
    posmove += verifyT(board, crows, ccols, rows, cols);

    //right upper cell
    posmove += verifyTR(board, crows, ccols, rows, cols);

    //lower left cell
    posmove += verifyLL(board, crows, ccols, rows, cols);

    //lower right cell
    posmove += verifyLR(board, crows, ccols, rows, cols);

    //lower cell
    posmove += verifyL(board, crows, ccols, rows, cols);
    
  }
  return posmove;
}










void printGameBoard(Cell** board,int rows, int cols, Player* players, int num_players, char** colors) {
    int a = (4 * rows) + 2;

    // display game map
    printf("\x1B[1;1H");
  int size=cols;
   if(size%2!=0){
    size = (size+1)/2;
    }
    else if(size%2==0){
    size=(size/2);
    }
    for (int i = 0; i < size-1; i++) {
        printf("  ______  ");
        printf("      ");
    }printf("  ______");

    for (int i = 0; i < rows; i++) {
        printHexagonLine(cols);
    }
    affichePenguin(board, rows, cols, num_players, colors);
    printfishes(board,rows,cols);
    printf("\x1B[4;120H       üëë");
    printf("\x1B[5;130H Bob : ");
    printf("\x1B[5;137H\x1B[48;2;255;128;0müêß\x1B[0m");

    // display names and scores of players
    printf("\x1B[%d;0H\n", a);
    printf("Joueurs :\n");

    for (int i = 0; i < num_players; i++) {
        printf("Joueur %d : %s\n", i + 1, players[i].player_name);
    }
    printf("\n");
}






void movepenguin(Cell** board,int rows, int cols,char** colors){
    printf("\x1B[30;1H");
    int oldrows =0;
    int oldcols =0;
    int newrows =0;
    int newcols =0;
    int player_index;

    do{
     
    printf("\x1B[K");
    printf("sur quelle ligne se situe le penguin que voulez vous deplacer ?\n");
    scanf("%d",&oldrows);
    printf("\x1B[F\x1B[K");
    printf("\x1B[E"); // D√©place le curseur vers la ligne suivante

    printf("\x1B[K");
    printf("sur quelle colonne situe le penguin que voulez vous deplacer ?\n");
    scanf("%d",&oldcols);
    printf("\x1B[F\x1B[K");
    printf("\x1B[E"); // D√©place le curseur vers la ligne suivante
    if(board[oldrows][oldcols].penguin==0){
        printf("\x1B[4F");
    }
    }while (board[oldrows][oldcols].penguin==0);
 player_index = board[oldrows][oldcols].penguin - 1; 
    board[oldrows][oldcols].penguin =0;// met la case sans pingouin et la casse
    board[oldrows][oldcols].broken =1;
    
    
    do{
	    do{
	    printf("\x1B[K");
	    printf("sur quelle ligne voulez vous deplacer votre penguin ?\n"); 
	    scanf("%d",&newrows);
	    printf("\x1B[F\x1B[K");
	    printf("\x1B[E"); 
	    if (newrows > rows-1 || newrows < 0) {
		printf("\x1B[2F");
	       	   
	    }   
	    }while (newrows > rows-1 || newrows < 0);
	    
	    do{
	    printf("\x1B[K");
	    printf("sur quelle colonne voulez vous deplacer votre penguin ?\n");
	    scanf("%d",&newcols);
	    printf("\x1B[F\x1B[K");
	    printf("\x1B[E"); // D√©place le curseur vers la ligne suivante
	    if (newcols > cols-1 || newcols < 0 ) {
		printf("\x1B[2F");
	       	   
	    } 
	    }while (newcols > cols-1 || newcols < 0);
        if(board[newrows][newcols].penguin ==1 || board[newrows][newcols].broken ==1 ){
		printf("\x1B[4F");       
        }
    }while (board[newrows][newcols].penguin ==1 || (newrows==0 && newcols%2!=0) || board[newrows][newcols].broken ==1 ); // verif qu'il n'y a pas d√©ja un pingouin
    
    board[newrows][newcols].penguin =1;// met un pingouin sur la nouvelle case
    
    if(oldcols%2==0){
        int posxx= (5+(oldcols*8));
        int posyy= (4+(oldrows*4));  
	printf("\x1B[%d;%dH",posyy-2,posxx-2);
	printf("üåäüåäüåä");
	printf("\x1B[%d;%dH",posyy-1,posxx-3);
	printf("üåäüåäüåäüåä");
	printf("\x1B[%d;%dH",posyy,posxx-3);
	printf("üåäüåäüåäüåä");
	printf("\x1B[%d;%dH",posyy+1,posxx-2);
	printf("üåäüåäüåä");

    }

    else{
            oldcols = oldcols-1;
        int posxx= (13+(oldcols*8));
        int posyy= (6+((oldrows-1)*4));
        printf("\x1B[%d;%dH",posyy-2,posxx-2);
	printf("üåäüåäüåä");
	printf("\x1B[%d;%dH",posyy-1,posxx-3);
	printf("üåäüåäüåäüåä");
	printf("\x1B[%d;%dH",posyy,posxx-3);
	printf("üåäüåäüåäüåä");
	printf("\x1B[%d;%dH",posyy+1,posxx-2);
	printf("üåäüåäüåä");
	
	
    }
     board[newrows][newcols].penguin = player_index + 1;
     if (newcols % 2 == 0) {
        int posx = 5 + (newcols * 8);
        int posy = 4 + (newrows * 4);
        printf("\x1B[%d;%dH%s", posy, posx, colors[player_index]);
    } else {
        newcols -= 1;
        int posx = 13 + (newcols * 8);
        int posy = 6 + ((newrows - 1) * 4);
        printf("\x1B[%d;%dH%s", posy, posx, colors[player_index]);
    }
        printboard(board,rows,cols);
}
    




  int better_scan(const char *prompt) {
    char input[100];  // Buffer to hold input
    int value, ret_var;

    while (1) {
        printf("%s", prompt);
        if (!fgets(input, sizeof(input), stdin)) {
            continue;  // If input fails, prompt again
        }

        // Try to convert the string to an integer
        ret_var = sscanf(input, "%d", &value);
        
        // Check for valid number range and correct conversion
        if (ret_var == 1 && value >= 2 && value <= 6) {
            return value;  // Return the value if it's a valid number
        }
        
        printf("Type in a valid number between 2 and 6.\n");
    }
} // fgets and sscanf will avoid a loop once the user types in a character or an invalid number.
    



int main() {
    int rows, cols;
    Player* players = NULL;
    int num_players;
	char* colors[MAX_PLAYERS] = {
        "\x1B[48;2;135;206;235müêß\x1B[0m", // Blue
        "\x1B[48;2;255;165;0müêß\x1B[0m",   // Orange
        "\x1B[48;2;124;252;0müêß\x1B[0m",   // Green
        "\x1B[48;2;255;0;255müêß\x1B[0m",   // Magenta
        "\x1B[48;2;255;255;0müêß\x1B[0m",   // Yellow
        "\x1B[48;2;0;255;255müêß\x1B[0m"    // Cyan
    };
    
    system("clear");
    num_players = better_scan("Enter the number of players (2 to 6): ");

    if (num_players < 2 || num_players > 6) {
        printf("Number of players must be between 2 and 6.\n");
        exit(EXIT_FAILURE);
    }

    players = malloc(sizeof(Player) * num_players);
    if (players == NULL) {
        printf("Error allocating memory for players\n");
        exit(EXIT_FAILURE);
    }
    
  
    setupPlayers(players, num_players, colors);
    
    // Fixation de la taille du plateau de jeu
    printf("Nombre de lignes du plateau de jeu : ");
    scanf("%d", &rows);
    printf("Nombre de colonnes du plateau de jeu (nombre impaire recquis): ");
    scanf("%d", &cols);
    if (cols%2==0){
    cols +=1;
    }
   

    // V√©rification de la validit√© de la taille du plateau de jeu
    if (rows < 1 || cols < 1 || rows > MAX_ROWS || cols > MAX_COLS) {
        printf("Taille du plateau invalide. Veuillez choisir des dimensions entre 1 et 9.\n");
        free(players);
        return 1;
    }
    system("clear");
    Cell** board = initializeBoard(rows, cols);


    
    // Affichage de la zone de jeu
    printGameBoard(board,rows, cols, players, num_players, colors);
    
    for(int i=0;i<10;i++){
    movepenguin(board, rows, cols, colors);
    printf("\x1B[20;1H");
    }
   

    int a = (4 * rows) + 10;
    printf("\x1B[%d;0H\n", a);
    
    free(players);
    freeBoard(board, rows);
    
    
    return 0;
    
    
}
